  @{include("./../Commons/header-common.i")}
  <link rel='stylesheet' href='@{siteAddress}/assets/reset.css?v=3'>
  <link rel='stylesheet' href='@{siteAddress}/assets/index.css?v=3'>
  <link rel='canonical' href='@{siteAddress}/assorted-notes/best-practices-for-access-tokens-angular-edition'>
  <title>Best Practices for access tokens - Angular edition</title>
</head>
<body class="my-content-page-1">
  <header>
  <div>
  <a href="@{siteAddress}/">Home</a>
  </div>
  </header>
  <main>
    <div class="left-column"></div>
    <div class="center-column">
    
    <h1>Best Practices for access tokens  - Angular Edition</h1>
    <p>
    Access tokens are essential for securing the communication of web applications with APIs.
    However, handling these tokens improperly can lead to security vulnerarbilities.
    </p>
    
    <p>
    This document describes best practices for handling access tokens in Angular applications, with pseudo-code examples.
    </p>
    
    <h2>1 Why storing access tokens matters</h2>
    <p>Access tokens contain sensitive information that provide access to protected resources.
    Storing them inappropriatly could expose your web application to several security risks, including:</p>
    
    <ul>
      <li><b>Cross-Site Scripting (XSS) Attacks</b>: If tokens are stored insecurely, attackers can access them through XSS vulnerabilities.</li>
      <li><b>Token Theft</b>: Improper storage of access tokens makes it easier for attacks to steal them an impersonate users.</li>
    </ul>
    
    <h2>2 Where to store access tokens</h2>
    
    <h3>2.1 Local storage (not recommended)</h3>
    <p><b>Local Storage</b> is persistent storage in the browser which retains the token until it is removed.
    It is *not safe* for storing sensitive data like access tokens due to vulnerabilities to XSS attacks.
    
    <p><code>
    localStorage.setItem('accessToken', token); /* This is not secure. */
    </code></p>
    
    <p><code>
    sessionStorage.setItem('accessToken', token); /* This is still not secure. */
    </code></p>
        
    <h3>2.2 Session storage (not recommended)</h3>
    <p><b>Session Storage</b> is persistent storage in the browser which retains the token until it is removed
    <em>or</em> the session ends (e.g., when the browser or the browser tab is closed). However, it is <em<still
    not safe</em> for storing sensitive data like access tokens due to vulnerabilities to XSS attacks.</p>
    
    <p><code>
    sessionStorage.setItem('accessToken', token); /* This is not secure. */
    </code></p>
    
    <h3>2.3 Cookies</h3>
    <p>A more secure storage is provided by cookies if the proper settings are used.
    You should use the <code>httpOnly : true</code>, <code>secure : true</code> and <code>sameSite : ''Strict'</code> settings.</p>
    
    <ul>
      <li><code>httpOnly : true</code> ensures that client-side scripts cannot access the token preventing certain XSS attacks.</li>
      <li><code>secure : true</code> ensures the token is only sent over HTTPS.</li>
      <li><code>sameSite : 'Strict'</code> prevents the cookie from being sent with cross-site requests.</li>
    </ul>
    
    <p><code>
    res.cookie<br>
    &nbsp;(<br>
    &nbsp;&nbsp;'accessToken',<br>
    &nbsp;&nbsp;token,<br>
    &nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;httpOnly: true,<br>
    &nbsp;&nbsp;&nbsp;secure: true,<br>
    &nbsp;&nbsp;&nbsp;sameSite: 'Strict',<br>
    &nbsp;&nbsp;}<br>
    &nbsp;);
    </code></p>

    <h2>3 How to send access tokens</h2>

    <p>In Angular, you can configure your HTTP client to send cookies with each request.</p>
    <p><code>
    import { HttpClient } from '@@angular/common/http';

    constructor(private http: HttpClient) {}
      getData() {
        return this.http.get('https://api.example.com/data', { withCredentials: true });
      }
    </code></p>
    
    <h2>4 How to encapsulate token handling</h2>
    <p>Create a <b>Token Service</b> in Angular to handle all token-related operations. This way, you centralize token storage and avoid directly accessing <code>localStorage</code>, <code>sessionStorage</code> or <code>res</code> in your code.</p>
    
    <p><code>
    import { Injectable } from '@@angular/core';<br>
    <br>
    @@Injectable({<br>
    &nbsp;providedIn: 'root'<br>
    })<br>
    export class TokenService {<br>
    ...<br>
    &nbsp;private ACCESS_TOKEN_KEY = 'accessToken';<br>
    &nbsp;constructor() {}<br>
    &nbsp;/* Set the token. */<br>
    &nbsp;public setToken(token: string): void {<br>
    &nbsp;&nbsp;sessionStorage.setItem(this.ACCESS_TOKEN_KEY, token);<br>
    &nbsp;}<br>
    &nbsp;/* Get the token. */<br>
    &nbsp;public getToken(): string | null {<br>
    &nbsp;&nbsp;return sessionStorage.getItem(this.ACCESS_TOKEN_KEY);<br>
    &nbsp;}<br>
    &nbsp;/* Remove the token. */<br>
    &nbsp;public removeToken(): void {<br>
    &nbsp;&nbsp;sessionStorage.removeItem(this.ACCESS_TOKEN_KEY);<br>
    &nbsp;}<br>
    ...<br>
    }
    </code></p>
    
    <h2>5 How to send tokens</h2>
   
    <p>Use Angular's <b>HTTP Interceptors</b> to attach access tokens to HTTP requests automatically,
    ensureing that *every* outgoing API call includes the required authentication token. <em>Strictly
    speaking this is not a security issue but a maintainability issue: If an API call does not include the
    token, then it would fail.</em></p>
    
    <p><code>
    import { Injectable } from '@@angular/core';<br>
    import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@@angular/common/http';<br>
    import { Observable } from 'rxjs';<br>
    import { TokenService } from './token.service';<br>
    <br>
    @@Injectable()<br>
    export class TokenInterceptor implements HttpInterceptor {<br>
    &nbsp;constructor(private tokenService: TokenService) {}<br>
    &nbsp;intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {<br>
    &nbsp;&nbsp;const token = this.tokenService.getToken();<br>
    &nbsp;&nbsp;if (token) {<br>
    &nbsp;&nbsp;&nbsp;const cloned = req.clone({<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: req.headers.set('Authorization', `Bearer ${token}`)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;});<br>
    &nbsp;&nbsp;&nbsp;return next.handle(cloned);<br>
    &nbsp;&nbsp;}<br>
    &nbsp;&nbsp;return next.handle(req);<br>
    &nbsp;}<br>
    }<br>
    </code></p>
    
    <h2>6 How to refresh access tokens</h2>
    <p>If your access token expires, in particular if it expires after a resonably short time which is recommended,
    use refresh tokens to obtain a new access token without requiring the user to re-authenticate.</p>

    <p><code>
    refreshToken() {<br>
    &nbsp;return this.http.post('https://api.example.com/refresh-token', {<br>
    &nbsp;&nbsp;token: this.tokenService.getRefreshToken()<br>
    &nbsp;&nbsp;}).subscribe((response: any) => {<br>
    &nbsp;&nbsp;this.tokenService.setToken(response.newAccessToken);<br>
    &nbsp;&nbsp;});<br>
    }
    </code></p>
    
    <p><code>
    import { Injectable } from '@@angular/core';<br>
    <br>
    @@Injectable({<br>
    &nbsp;providedIn: 'root'<br>
    })<br>
    export class TokenService {<br>
    ...<br>
    &nbsp;private REFRESH_TOKEN_KEY = 'refreshToken';<br>
    &nbsp;constructor() {}<br>
    &nbsp;/* Set the refresh token. */<br>
    &nbsp;public setRefreshToken(token: string): void {<br>
    &nbsp;&nbsp;sessionStorage.setItem(this.REFRESH_TOKEN_KEY, token);<br>
    &nbsp;}<br>
    &nbsp;/* Get the refresh token. */<br>
    &nbsp;public getRefreshToken(): string | null {<br>
    &nbsp;&nbsp;return sessionStorage.getItem(this.REFRESH_TOKEN_KEY);<br>
    &nbsp;}<br>
    &nbsp;/* Remove the refresh token. */<br>
    &nbsp;public removeRefreshToken(): void {<br>
    &nbsp;&nbsp;sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);<br>
    &nbsp;}<br>
    ...<br>
    }
    </code></p>
    
    <h2>7 How to clear access tokens on logout</h2>
    <p>Clear tokens on logout.</p>
    <p><code>
    public clearSession(): void {<br>
    &nbsp;sessionStorage.clear();<br>
    }
    </code></p>

    <h2>8 Summary</h2>
    <h3>Apply best practices</h3>
    <p>Apply the following best practices:</p>
    <ul>
      <li>Use <b>Cookies</b> with <code>httpOnly : true</code>, <code>secure : true</code> and <code>sameSite : 'Strict'</code> settings.
      <li>Avoid <b>Local Storage</b> and <b>Session Storage</b>.</li>
      <li>Encapsulate token management in a <b>Token Service</b>.</li>
      <li>Use Angular <b>HTTP Interceptors</b>.</li>
      <li>Use short-lived access tokens and refresh tokens.</li>
      <li>Clear tokens on logout.</li>
    </ul>
    
    <h2>9 Address security concerns</h2>
    <p>Address the following security concerns:</p>

    <h3>9.1 Cross-Site Scripting (XSS)</h3>
    <p><b>Concern</b>: XSS attacks can expose access tokens.</p>
    <p><b>Solution</b>: The best way to prevent this is by not storing tokens in locations like <b>localStorage</b> or <b>sessionStorage</b>.
    Use <b>Cookies</b> with <code>sameSite : 'Strict'</code> settings to prevent JavaScript access and mitigate XSS attacks.</p>
    
    <h3>9.2 Cross-site request forgery (CSRF)</h3>
    <p><b>Concern</b>: When using <b>Cookies</b> to store access tokens, the web application becomes vulnerable to CSRF attacks.
    Attackers can trick users into making unintended requests.</p>
    <p><b>Solution</b>: Use session cookies with `sameSite : ''Strict'` settings to prevent the browser from sending cookies with cross-origin requests.</p>

    <h3>9.3 Token theft via insecure storage</h3>
    <p><b>Concern</b>: Storing tokens in browser storage without encryption exploses them to attackers, especially in shared environments.</p>
    <p><b>Solution</b>: Avoid browser storage for sensitive tokens and ensure tokens are short-lived and regularly refreshed.</p>
    
    
  </div>
  <div class="right-column"></div>
  </main>
  <footer>
    <div class="left-column"></div>
    <div class="center-column">

    </div>
    <div class="right-column">
      <div>Website maintained by @{siteAuthor}.</div>
      <div>Last modified on @{dayOfMonth()} @{monthName()} @{year()}.</div>
    </div>
  </footer>
</body>
</html>
